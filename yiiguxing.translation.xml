<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="420" />
    <option name="newTranslationDialogWidth" value="377" />
    <option name="newTranslationDialogX" value="221" />
    <option name="newTranslationDialogY" value="164" />
    <histories>
      <item value="Const 'val' has type 'FileLog.Companion.CrashThrowable'. Only primitives and String are allowed" />
      <item value="Do not place Android context classes in static fields (static reference to FileLog which has field context pointing to Context); this is a memory leak" />
      <item value="Decode Runnable" />
      <item value="Proceed in 3 steps: 1. If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task. The call to addWorker atomically checks runState and workerCount, and so prevents false alarms that would add threads when it shouldn't, by returning false. 2. If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none. 3. If we cannot queue task, then we try to add a new thread. If it fails, we know we are shut down or saturated and so reject the task." />
      <item value="single Thread Pool" />
      <item value="Finalizable Delegated Executor Service" />
      <item value="hook for ScheduledThreadPoolExecutor" />
      <item value="interrupt Idle Workers" />
      <item value="Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of five things happens: Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or The specified waiting time elapses; or A &quot;spurious wakeup&quot; occurs. In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting and interruption of thread suspension is supported, then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. The method returns an estimate of the number of nanoseconds remaining to wait given the supplied nanosTimeout value upon return, or a value less than or equal to zero if it timed out. This value can be used to determine whether and how long to re-wait in cases where the wait returns but an awaited condition still does not hold. Typical uses of this method take the following form: boolean aMethod(long timeout, TimeUnit unit) { long nanos = unit.toNanos(timeout); lock.lock(); try { while (!conditionBeingWaitedFor()) { if (nanos &lt;= 0L) return false; nanos = theCondition.awaitNanos(nanos); } ... } finally { lock.unlock(); } } Design note: This method requires a nanosecond argument so as to avoid truncation errors in reporting remaining times. Such precision loss would make it difficult for programmers to ensure that total waiting times are not systematically shorter than specified when re-waits occur. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal, or over indicating the elapse of the specified waiting time. In either case the implementation must ensure that the signal is redirected to another waiting thread, if there is one." />
      <item value="run State At Least" />
      <item value="await Termination" />
      <item value="new Single Thread Executor" />
      <item value="update Cache Picture" />
      <item value="rotate" />
      <item value="旋转" />
      <item value="request Fail And Exit" />
      <item value="Unreachable code" />
      <item value="please Login" />
      <item value="Data class must have at least one primary constructor parameter" />
      <item value="TRY HARDER" />
      <item value="15 rows spaced 132 apart is roughly the middle half of the image" />
      <item value="Look at the whole image, not just the center" />
      <item value="rowNumber - row number from top of the row row - the blackwhite pixel data of the row hints - decode hints Returns:" />
      <item value="escription copied from class: OneDReader Attempts to decode a one-dimensional barcode format given a single row of an image. Specified by: decodeRow in class OneDReader" />
      <item value="Multi Format One D Reader" />
      <item value="Inverted Luminance Source" />
      <item value="Hybrid Binarizer" />
      <item value="RGB Luminance Source" />
      <item value="Spend more time to try to find a barcode; optimize for accuracy, not speed. Doesn't matter what it maps to; use" />
      <item value="CODABAR 1D format." />
      <item value="Image is known to be of one of a few possible formats. Maps to a List of BarcodeFormats." />
      <item value="Bar Code" />
      <item value="UPCEAN extension format. Not a stand-alone format." />
      <item value="Interleaved Two of Five" />
      <item value="ITF (Interleaved Two of Five) 1D format." />
      <item value="Aztec 2D barcode format." />
      <item value="Enumerates barcode formats known to this package. Please keep alphabetized. Author: Sean Owen All Implemented Interfaces: Serializable , Comparable &lt;BarcodeFormat&gt;" />
      <item value="raw text encoded by the barcode" />
      <item value="条形码" />
      <item value="check Task Over" />
      <item value="This is an internal kotlinx.coroutines API that should not be used from outside of kotlinx.coroutines. No compatibility guarantees are provided.It is recommended to report your use-case of internal API to kotlinx.coroutines issue tracker, so stable API could be provided instead" />
      <item value="You specify which Scheduler this operator will use. &quot;Island size&quot; indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed on the other side of the asynchronous boundary." />
      <item value="This operator keeps emitting as many signals as it can on the given Scheduler's worker thread, which may result in a longer than expected occupation of this thread. In other terms, it does not allow per-signal fairness in case the worker runs on a shared underlying thread. If such fairness and signalwork interleaving is preferred, use the delay operator with zero time instead." />
      <item value="Returns an Observable to perform the current Observable's emissions and notifications on a specified Scheduler, asynchronously with an unbounded buffer with Flowable.bufferSize() &quot;island size&quot;. Note that onError notifications will cut ahead of onNext notifications on the emission thread if Scheduler is truly asynchronous. If strict event ordering is required, consider using the observeOn(Scheduler, boolean) overload." />
      <item value="Return an Observable that schedules the downstream Observers' dispose calls aimed at the current Observable on the given Scheduler." />
      <item value="Accidental override: The following declarations have the same JVM signature (getTaskId()I):" />
      <item value="submits" />
      <item value="Defines whether the vertical scrollbar track should always be drawn." />
      <item value="Hints the Android System whether the view node associated with this View should be included in a view structure used for autofill purposes." />
      <item value="When set to false, prevents the layout from aligning its children's baselines. This attribute is particularly useful when the children use different values for gravity. The default value is true." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1316" />
        <entry key="ENGLISH" value="1317" />
        <entry key="DANISH" value="3" />
        <entry key="GERMAN" value="8" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="FILIPINO" value="1" />
        <entry key="CATALAN" value="2" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALAYALAM" value="1" />
        <entry key="BENGALI" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="3" />
        <entry key="SLOVAK" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="GREEK" value="1" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1625981092706" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200918000568375" />
      </app-key>
    </option>
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="2f2d5e6a9f7e1244" />
      </youdao-translate>
    </option>
  </component>
</application>