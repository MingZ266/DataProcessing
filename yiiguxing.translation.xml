<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="420" />
    <option name="newTranslationDialogWidth" value="375" />
    <option name="newTranslationDialogX" value="221" />
    <option name="newTranslationDialogY" value="164" />
    <histories>
      <item value="Checksum mismatch for dex base.apk!classes2.dex" />
      <item value="Only the original thread that created a view hierarchy can touch its views." />
      <item value="readLoop mReadIndex finish" />
      <item value="set Fan Mode" />
      <item value="sensor paper out" />
      <item value="Capturer" />
      <item value="uevent_next_event nr:1" />
      <item value="Build fingerprint: 'HuagoScanrk3288rk3288:8.1.0OPM8.181205.001095200:userdebugtest-keys'" />
      <item value="SEGV MAPERR" />
      <item value="SIGSEGV" />
      <item value="Fatal signal 11 (SIGSEGV), code 1, fault addr 0x84380000 in tid 3635 (pool-2-thread-1), pid 3537 (ple.scanningapp)" />
      <item value="stack Top" />
      <item value="stack Trace" />
      <item value="The (optional) fully-qualified name for a subclass of {@link android.app.Application} that the system instantiates before any other class when an app's process starts. Most applications don't need this attribute. If it's not specified, the system instantiates the base Application class instead." />
      <item value="Const 'val' has type 'FileLog.Companion.CrashThrowable'. Only primitives and String are allowed" />
      <item value="Do not place Android context classes in static fields (static reference to FileLog which has field context pointing to Context); this is a memory leak" />
      <item value="Decode Runnable" />
      <item value="Proceed in 3 steps: 1. If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task. The call to addWorker atomically checks runState and workerCount, and so prevents false alarms that would add threads when it shouldn't, by returning false. 2. If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none. 3. If we cannot queue task, then we try to add a new thread. If it fails, we know we are shut down or saturated and so reject the task." />
      <item value="single Thread Pool" />
      <item value="Finalizable Delegated Executor Service" />
      <item value="hook for ScheduledThreadPoolExecutor" />
      <item value="interrupt Idle Workers" />
      <item value="Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of five things happens: Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or The specified waiting time elapses; or A &quot;spurious wakeup&quot; occurs. In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting and interruption of thread suspension is supported, then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. The method returns an estimate of the number of nanoseconds remaining to wait given the supplied nanosTimeout value upon return, or a value less than or equal to zero if it timed out. This value can be used to determine whether and how long to re-wait in cases where the wait returns but an awaited condition still does not hold. Typical uses of this method take the following form: boolean aMethod(long timeout, TimeUnit unit) { long nanos = unit.toNanos(timeout); lock.lock(); try { while (!conditionBeingWaitedFor()) { if (nanos &lt;= 0L) return false; nanos = theCondition.awaitNanos(nanos); } ... } finally { lock.unlock(); } } Design note: This method requires a nanosecond argument so as to avoid truncation errors in reporting remaining times. Such precision loss would make it difficult for programmers to ensure that total waiting times are not systematically shorter than specified when re-waits occur. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal, or over indicating the elapse of the specified waiting time. In either case the implementation must ensure that the signal is redirected to another waiting thread, if there is one." />
      <item value="run State At Least" />
      <item value="await Termination" />
      <item value="new Single Thread Executor" />
      <item value="update Cache Picture" />
      <item value="rotate" />
      <item value="旋转" />
      <item value="request Fail And Exit" />
      <item value="Unreachable code" />
      <item value="please Login" />
      <item value="Data class must have at least one primary constructor parameter" />
      <item value="TRY HARDER" />
      <item value="15 rows spaced 132 apart is roughly the middle half of the image" />
      <item value="Look at the whole image, not just the center" />
      <item value="rowNumber - row number from top of the row row - the blackwhite pixel data of the row hints - decode hints Returns:" />
      <item value="escription copied from class: OneDReader Attempts to decode a one-dimensional barcode format given a single row of an image. Specified by: decodeRow in class OneDReader" />
      <item value="Multi Format One D Reader" />
      <item value="Inverted Luminance Source" />
      <item value="Hybrid Binarizer" />
      <item value="RGB Luminance Source" />
      <item value="Spend more time to try to find a barcode; optimize for accuracy, not speed. Doesn't matter what it maps to; use" />
      <item value="CODABAR 1D format." />
      <item value="Image is known to be of one of a few possible formats. Maps to a List of BarcodeFormats." />
      <item value="Bar Code" />
      <item value="UPCEAN extension format. Not a stand-alone format." />
      <item value="Interleaved Two of Five" />
      <item value="ITF (Interleaved Two of Five) 1D format." />
      <item value="Aztec 2D barcode format." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1327" />
        <entry key="ENGLISH" value="1328" />
        <entry key="ICELANDIC" value="1" />
        <entry key="DANISH" value="3" />
        <entry key="GERMAN" value="8" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="3" />
        <entry key="FILIPINO" value="1" />
        <entry key="CATALAN" value="2" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALAYALAM" value="1" />
        <entry key="BENGALI" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="3" />
        <entry key="SLOVAK" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="GREEK" value="1" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1625981092706" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200918000568375" />
      </app-key>
    </option>
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="2f2d5e6a9f7e1244" />
      </youdao-translate>
    </option>
  </component>
</application>